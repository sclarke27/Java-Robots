<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<title>Frequently Asked Questions About Jikes (September 17, 1999)</title>
</head>

<body>

<h2 align="center">Jikes Project</h2>
<h2 align="center">http://ibm.com/developerworks/opensource</h2>
<h2 align="center">Frequently Asked Questions About Jikes</h2>
<h2 align="center">September 17, 1999</h2>
<p>
<h2>About Jikes</h2>

<p><br>
<a href="#what_is"><b>What is Jikes?</b></a> <br>
<a href="#usage"><b>How do I use it? What options does it support?</b></a><br>
<a href="#jikespath"><b>Why must I define <code>CLASSPATH</code>? What is <code>JIKESPATH</code>?</b></a><br>
<a href="#listing"><b>How do I control the compiler listing?</b></a><br>
<a href="#incremental"><b>What is incremental compilation?</b></a><br>
<a href="#make"><b>How do I use Jikes to generate dependencies for make?</b></a><br>
<a href="#compatible"><b>
Why does Jikes reject a program that another compiler accepts, or accept one that it rejects?</b></a><br>
<a href="#results"><b>
What can I do if I don't get the same results when using class files generated by Jikes?</b></a><br>
<a href="#bugs"><b>How do I report bugs?</b></a>
<h2>About Jikes Source</h2>
<p>
<a href="#whyis"><b>Why did IBM make the source available?</b></a><br>
<a href="#whatcanido"><b>What can I do with the source?</b></a><br>
<a href="#build"><b>How do I compile the source?</b></a><br>
<a href="#test"><b>How do I test the compiler?</b></a><br>


<h3><a name="what_is"><b>What is Jikes?
</b></a></h3>
<p>
Jikes is a compiler that translates Java source files as
defined in
<a href="http://www.java.sun.com/docs/books/jls">
The Java Language Specification</a>
into the bytecoded instruction set and binary format defined in
<a href="http://www.java.sun.com/docs/books/vmspec">
The Java Virtual Machine Specification</a>.
Features include:
<ul>
<li>strict adherence to the language specification,
<li>extremely fast compile speed,
<li>built-in dependence analysis, allowing incremental
compilation and automatic makefile generation.
</ul>

<p>
We provide the source code for Jikes, a parser generator, and a test suite under a liberal 
<a href="license/index.htm">license</a>.

<p>Two versions are available for downloading:
<ul>
<li> 
<a href="http://ibm.com/developerworks/opensource">Development Jikes (developerWorks)</a>: the most recent version of the source.
<li> 
<a href="http://alphaWorks.ibm.com/tech/jikes">Stable Jikes (alphaWorks)</a>: an earlier development 
version that has proven stable after use in the field.
</ul>
We provide pre-built binary versions for AIX, Linux Intel, Solaris Sparc,
and Win95/NT. See
<a href="ports.htm">ports</a> for a list of known ports to other systems; some of the authors of these ports also 
provide binary versions.
<p>
Developers, including
<a href="contrib.htm">contributors</a>,
 communicate using the
Jikes
<a href="subscribe/index.htm">mailing lists</a>.
We also maintain the <a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf">Jikes Discussion Database</a>,
which contains problem reports, suggestions, and several queries to Sun about language specification issues.

<p>

The original version of Jikes, first released in binary form in April
1997, was written by Philippe Charles and Dave Shields of the IBM T.
J. Watson Research Center.  Since the release of the source in
December 1998 they have continued to work on the compiler as
contributors.

<p>
Here are links to some of the articles in the press that have mentioned Jikes:
<p>
PC Week (December 1998): 
<a href="http://www.zdnet.com/pcweek/stories/news/0,4153,375509,00.html">
Jikes! More open source code.</a>
<br>
Javaworld (December 1998): 
<a href="http://www.javaworld.com/pr/awards98.html#1">
JavaWorld announces finalists in its 1998 Editor's Choice Awards.</a>
<br>
Computing (April 1998): 
<a href="http://www.zdnet.com/products/content/zdim/0304/288352.html"> 
Internet Java Tools Enrich the Bean Pool.</a>
<br>
PC Week (December 1997): <a href="http://www.zdnet.com/pcweek/sr/1222/22prod97.html">
PCW Labs' top 10 tech trends: It was the best of information technology.</a>
<br>
PC Week (September 1997):  
<a href="http://www.pcweek.com/news/0922/22tech.html">
IBM spreading its software wings.</a>
<br>
Infoworld (May 1997): 
<a href="http://www.haifa.il.ibm.com/webcutter/infoworld/infoworld24May.html">
IBM to invest $100 million in Internet, networking research center this year.</a>
<br>
Web Week (April 1997): 
<a href="http://www.webweek.com/97Apr28/software/rails.html">
IBM Greases Java's Rails.</a>
<br>
PC Week (April 1997): 
<a href="http://www.pcweek.com/news/0414/14ante.html">
IBM, Netscape Up Web Ante.</a>


<h3><a name="usage"><b>How do I use it? What options does it
support?</b></a></h3>

<p>Invoke Jikes in the form:
<pre>
    jikes options filename...
</pre>

Invoke Jikes with no arguments to see a short summary of the
arguments. Allowed options are:


<dl>
    <dt><code>-classpath path</code> </dt>
    <dd>Set classpath.</dd>
    <dt><code>-d dir</code></dt>
    <dd>Write class files in specified directory.</dd>
    <dt><code>-debug</code> </dt>
    <dd>No effect (recognized for compatibility with many compilers).
    </dd>
    <dt><code>-depend</code> </dt>
    <dd>Recompile all used classes.
    </dd>
    <dt><code>-deprecation</code> </dt>
    <dd>Report on use of deprecated features.</dd>
    <dt><code>-g</code></dt>
    <dd>Generate <code>LocalVariableTable</code> attribute.
    </dd>
    <dt><code>-nowarn</code></dt>
    <dd>Suppress warning messages.</dd>
    <dt><code>-nowrite</code></dt>
    <dd>Do not write any class files.</dd>
    <dt><code>-O</code> </dt>
    <dd>Do not generate <code>LineNumberTable</code> attribute.</dd>
    <dt><code>-verbose</code></dt>
    <dd>List files read and written.</dd>
    <dt><code>-Xdepend</code> </dt>
    <dd>Recompile all used classes.
    </dd>
    <dt><code>-Xdepend</code></dt>
    <dd>Another way of writing -depend, for JDK 1.2 compatibility.</dd>
    <dt><code>-Xstdout</code></dt>
    <dd>Write error messages to standard output.</dd>
    <dt><code>++</code></dt>
    <dd>Compile in incremental mode.</dd>
    <dt><code>+1.0</code></dt>
    <dd>Recognize only the 1.0 level of the language, reporting as errors
        any uses of features added in the 1.1 level.</dd>
    <dt><code>+B</code></dt>
    <dd>Do not generate bytecode. This is used primarily for debugging
        the compiler. <code>-nowrite</code> generates byte code but does
        not write it out.</dd>
    <dt><code>+D</code></dt>
    <dd>List errors immediately in emacs-form without buffering. This is only needed if
    Jikes is crashing and you want to see errors as soon as they are detected; ordinarily
    errors are sorted and listed at the end of the compilation.</dd>
    <dt><code>+E</code></dt>
    <dd>List errors in a form commonly used by <em>emacs</em> to
        scan for errors. By default errors are listed in a more readable
        form. </dd>
    <dt><code>+F</code></dt>
    <dd>Do full dependence check except for Zip and Jar files.</dd>
    <dt><code>+M</code></dt>
    <dd>Generate makefiles with dependencies.</dd>
    <dt><code>+M=filename</code></dt>
    <dd>Write report of dependencies to specified file.</dd>
    <dt><code>+P</code></dt>
    <dd>Generate pedantic listing.</dd>
    <dt><code>+Tnn</code></dt>
    <dd>Set tab width for listing error messages.</dd>
    <dt><code>+U</code></dt>
    <dd>Do full dependence check including Zip and Jar files.</dd>
    <dt><code>+Z</code></dt>
    <dd>Treat cautions as errors.</dd>
    
</dl>

<p>Jikes can be used to compile more than one file at a time, causing
a class file to be created for each Java source file. It is possible
that compilation of a file named early on in the argument list will
force the compilation of a file that is also named later on; however,
no file will be compiled more than once.  Jikes allows the same file
to be named more than once; however, such files are only compiled
once:
<pre>
        jikes Test.java x.java Test.java

</pre>

<p>Jikes also accepts arguments starting with an at-sign (@). Such
arguments are taken be the name of a file, each line of which is then
processed as though it were itself an argument, except that lines so
read that begin with an at-sign are not processed recursively. For
example, the above command could also be written as:
<pre>
        jikes @file.list
</pre>
where <code>file.list</code> is a file containing the lines:
<pre>
        Test.java
        x.java
        Test.java
</pre>

<h3><a name="jikespath"><b>

Why must I define <code>CLASSPATH</code>? What is <code>JIKESPATH</code>?
</b></a> </h3>

<p>You must have some version of the JDK or JRE to run Jikes, so the
compiler can access the standard class files.  Note that versions 1.1
of the JDK do not require that you provide a definition of
<code>CLASSPATH</code> to run <code>javac</code> and
<code>java</code>. However, Jikes doesn't know what version of the
JDK you are using and so must be told how to find the standard
library files. This can be done in three ways:
<ul>
<li>Provide a definition of <code>CLASSPATH</code>; for example, in Win95 this takes the form
<pre>
    SET CLASSPATH=.;C:\JAVA\LIB\CLASSES.ZIP
</pre>
or for example, in Linux:
<pre>
    export CLASSPATH=.:/usr/local/jdk.1.1.6/lib/classes.zip (jdk)
    export CLASSPATH=.:/usr/local/jre1.1.6/lib/rt.jar   (jre)
</pre>
</li>
<li>Always specify a value for the <code>-classpath</code> option on the command line;
for example:
<pre>
    jikes -classpath .:$HOME/java/lib/classes.zip ...
</pre>
</li>
<li>Use <code>JIKESPATH</code> as discussed below.
</ul>

<p>Jikes allows the use of <code>JAR</code> files, which have the
standard "zip" format, provided that any contained <code>class</code>
files are stored either using no compression or the default
"DeflatedN" compression (also known as "method 8" in zip-speak).
Indeed, any item in the class path that is a not a directory is
assumed to be a file in zip format.  The code used to do the the
uncompression is based on that used in <code>unzip532</code> from
Info-ZIP, so we have to make the following statement:
<blockquote>Jikes incorporates compression code from the Info-ZIP
   group. There are no extra charges or costs due to the use of
   this code, and the original compression sources are freely
   available from <a href="http://www.cdrom.com/pub/infozip/">Info-ZIP</a> or 
   <a href="ftp://ftp.cdrom.com/pub/infozip/">Info-ZIP ftp site</a> on the Internet.
</blockquote>

<p>Jikes looks for a definition of <code>JIKESPATH</code> in the
environment before it looks for a definition of
<code>CLASSPATH</code>. If <code>JIKESPATH</code> is defined, then
its value is used when looking for a class file.

<p>You should <em>almost always</em> include "." in the classpath;
omit it only if you understand the implications.

<h3>
<a name="listing">
<b>
How do I control the compiler listing?
</b></a></h3>
Jikes does not produce a compiler listing in the usual sense, but only writes out cautions, warnings and errors.
<p>
A caution is more severe than a warning,
but normally does not prevent the writing of the class file. The <code>+Z</code> option can be used to prevent the writing of a class file if any cautions are detected.

<p>A number of options select the kind and volume of the information
produced. They are <code>-nowarn</code>, <code>-verbose</code>,
<code>+E</code> and <code>+P</code>. The first two are found in most
Java compilers: <code>-nowarn</code> requests that warning messages
not be written, <code>-verbose</code> requests a report on the files,
including source and class files, read and written by the compiler.

<p>The error kind option <code>+E</code> is used to select how error
messages are formatted, By default, error messages are written in a
long form with the part of the text the compiler is complaining about
underlined, and with detailed explanatory text. The <code>+E</code>
option requests a terser form, suitable for automatic parsing by
editors such as <a
href="http://www.gnu.org/software/emacs/emacs.html">
<code>emacs</code> </a>
and 
<a href="http://www.lugaru.com"><code>epsilon</code></a>. For example, consider the mis-typed "hello world" example:
<pre>
class hello {
   public static void main(String[] args) {
     system.out.println("hi there"); // should be System...
   }
}
</pre>
When <code>+E</code> is not used, the error is reported as
<pre>
Found 1 semantic error compiling "hello.java":

     3.      system.out.println("hi there"); // should be System...
             <-------->
*** Semantic Error: "system/out" is either a misplaced package name or a non-existent entity.

</pre>
With <code>+E</code> is used, the error is reported as:
<pre>
hello.java:3:6:3:15: Semantic:"system/out" is either a misplaced package name or a non-existent entity.
</pre>
The initial part of each line contains several fields, separated by colons, giving in order the file name, the starting line in the file, the starting column in the starting
line, the ending line, and the column number in the ending line.

<p> The pedantic option <code>+P</code> is used to request a
complete, pedantic listing.  Just what is or is not pedantic
depends in part on e-mail we have received in which users have noted
that Jikes complains about constructs that other compilers accept.
(It is an open question whether the other compilers choose not to
report this information, or whether they do not even discover it.)
Select this option for a detailed listing. Currently, the following are only reported if <code>+P</code> is selected:
<ul>
<li>No type declarations:
<pre>
   This compilation unit contains no type declaration
</pre>
</li>
<li>Empty declarations, typically the result of an extraneous semicolon:
<pre>
   An EmptyDeclaration is a deprecated feature that should not be used
</pre>
</li>
<li>Attempt to overwrite method with <code>private</code> access:
<pre>
    Note that the method ... in class ... does not override the corresponding 
    method with private access in class ...
</pre>
</li>
<li>Attempt to overwrite default method:
<pre>
    The method ... in class ... does not override the corresponding 
    method with default access in class ...
</pre>
</li>
<li>

Access to a type defined in unnamed package. This message is issued
in response to the comment in section 7.4.2 of the specification that
"It is recommended that a Java system provide safeguards against
unintended consequences in situations where compiliation units of
named packages import types from unnamed packages."
<pre>
   The type associated with this construct is (or depends on) the type ...
   which is contained in an unnamed package
</pre>
</li>
</ul>

<p>
We say <code>C</code> depends on <code>D</code> if and only if the constant pool for <code>C</code> contains a reference
 to <code>D</code>. 
Types so referenced may need to be incorporated into the compilation, either by reading their class file or 
compiling a source file
to produce the needed class file. Incorporation is done as follows:
<ul>
<li>
If there is no class file and there is a source file, then the source file is compiled.</li>
<li>
If there is no source file and there is a class file, then the class file is read.</li>
<li>
If both a class file and a source file exist, then the class file is read only if it is newer than the source file;
otherwise the source file is compiled.</li>
<li>
If there is no class file and no source file, an error is reported.</li>
</ul>
(The effect of the <code>-depend</code> option is to always compile a source file if there is one).

<p>
By default, Jikes does not incorporate <code>D</code> unless it must.

<p>
If <code>+F</code> is specified, and <code>C</code> does not belong to a Zip or Jar file, the type <code>D</code> is incorporated. Otherwise, D is
incorporated only if it must be.

<p>
If <code>+U</code> is specified, then <code>D</code> is always incorporated.

<p>
Most compilers appear to use the same behavior as provided by Jikes by default. 

<p> You should only need to use <code>+F</code> and <code>+U</code>
for special situations.  You can use <code>+F</code> to get reports
of errors and warnings resulting from the use of out-of-date or
non-existent classes, at the expense of increasing compilation time.
By default, Jikes assumes that class files placed in Zip and Jar
files do not reference files not contained in Zip or Jar files; the
<code>+U</code> option should be used when this is not the case.


<h3><a name="incremental"><b>
What is incremental compilation?
</b></a></h3>

<p>Most Java compilers support at least some form of dependency
resolution, where we say that file <code>A</code> <em>depends</em> on
file <code>B</code> if a change to <code>B</code> implies that
<code>A</code> must be rebuilt.  For example, <code>A.class</code>
depends on the source file defining <code>A</code>, usually
<code>A.java</code>.  The <em>make</em> program is commonly used to
record the dependencies and keep files up to date.  <p>Many Java
compilers support a simple make-like function, as follows: when
compiling <code>A</code> check all classes referred to by
<code>A</code> and recompile any whose class file is older than the
source file. This approach can cause problems if this implies
recompiling <code>B</code>, and B is up to date, but uses
<code>C</code> which is out of date, in which case <code>C</code> may
not be recompiled.

<p> Jikes supports the option <code>-depend</code> and interprets it
as a request to recompile all used classes whether or not they are up
to date with respect to their source file.  <p>Jikes also supports
the option <code>+F</code> to force a fuller check of dependency. If
compilation of <code>A.java</code> requires <code>B.class</code> then
<code>B</code> will be recompiled if it is out of date. Once
<code>B.class</code> is available, it is read, and any classes it
references are also checked for dependencies. This fuller check is
more expensive, but will not cause the problems that can result using
the simple approach used by many compilers.

<p>Jikes can also be run in an <em>incremental</em> mode that works
as follows:
<ul>
<li> Open a window and compile your program using
<pre>
    jikes ++ Main.java
</pre>
where <code>Main.java</code> denotes your root source file. Jikes
will then compile <code>Main.java</code> and all the files it
references, building a complete set of dependencies, and will then
wait for input. (Note that <code>++</code> implies <code>+F</code> also.)</li>

<li>Modify your source files using your favorite editor until you
are ready to rebuild your program, and then type an empty line
in the window in which Jikes is waiting. Jikes will then determine
which source files have been changed, and will then perform the minimum
number of compilations needed to bring to class files into a complete
and consistent state. You can repeat this cycle as you wish, until you</li>

<li>Terminate the compilation by typing a single line 
<pre>
    q
</pre>
in the window in which Jikes is waiting. Jikes will then terminate.
</ul>

<p>By the way, you may notice a substantial delay after you type
<code>q</code> to end the incremental mode. This results from the
time needed to execute the destructors invoked to delete all the
nodes in the abstract syntax tree, all the symbols in the symbol
table, etc.  This cost is also incurred whenever the compiler must
delete its current in-memory data structures before compiling a
changed file. We are aware of this cost and are looking at ways to
reduce it, but are making the compiler available with this known
performance limitation so you can try it and test it for correctness.

<h3><a name="make"><b>How do I use Jikes to generate dependencies for make?
</b></a></h3>

<p>Most <code>C</code> and <code>C++</code> compilers support the
option <code>-M</code> to generate dependency information for use
with make. Jikes provides the same function for Java using the option
<code>+M</code>, which requests that Jikes create a file
<code>X.u</code> for each file <code>X.class</code> that is compiled,
and include in this file a list of all the files that
<code>X.class</code> depends on. Note that use of the <code>+M</code>
option turns on full dependency checking (as is done by the
<code>+F</code> option).

<p>The contents of any zip files in <code>CLASSPATH</code> are
assumed to be fixed, and so are not included in the generated
makefiles, mainly to avoid cluttering up the dependency list with
voluminous dependencies on the contents of <code>java.*</code>.

<p>You can also use the option <code>+M=filename</code> to request
that a dependence report be written to the file
<code>filename</code>. The format is designed to allow the use of the
information as input to a tool; for example, it could be used for a
tool that determines the minimum set of class files that must be
included in a <code>jar</code> file.

<h3><a name="compatible"><b>
Why does Jikes reject a program that another compiler accepts, or accept one that it rejects?
</b></a></h3>
<p>
You may find that Jikes accepts a program that another compiler
rejects (or can't compile), or rejects programs that another compiler
accepts. 

<p>
Each version of Jikes represents our best effort at the proper
interpretation of the language specification. Although Jikes is
designed to work with all but the earliest versions of the JDK, we
make no claim that any particular version supports precisely the same
language as any particular version of the JDK.  Since some products
are designed to work with specific versions of the JDK, the compilers
associated with them may not always recognize the same programs as
Jikes.

<p>
This section contains some examples of issues related to interpreting
the specification.

<h4>Extraneous Semicolons</h4>
<p>Your program may
contain extraneous semicolons that are silently ignored by many compilers.
For example, given
<pre>
   public class Test {
      void f() {};          // first extra semicolon
   };                       // second extra semicolon
</pre>
Jikes accepts the program but issues:
<pre>
     2.       void f() {};       // first extra semicolon
*** Warning: An EmptyDeclaration is a deprecated feature that 
             should not be used - ";" ignored

     3.    };                   // second extra semicolon
            ^
*** Warning: An EmptyDeclaration is a deprecated feature that
             should not be used - ";" ignored
</pre>
The first extra semicolon is erroneous, the second is allowed by section 7.6.
Jikes treats each as cause to issue a warning. You can use the <code>-nowarn</code>
option to suppress this (and other) warnings, or, even better, you can use
your editor to delete those extra semicolons.
<h4>Unreachable Statements</h4>
<p>It is a compile-time error if a statement cannot be executed because
it is <em>unreachable</em> (section 14.19).
When Jikes first appeared, some other compilers didn't properly detect unreachable statements,
and accepted programs such as the following:
<pre>
   class Test {
      void method(boolean b) {
         if (b) return;
         else return;
         b = !b;
      }
   }
</pre>
Jikes rejected this program:
<pre>
            b = !b;
            <----->
    *** Semantic Error: This statement is unreachable
</pre>
(This is the example referrred to in 
<a href="http://www.pcweek.com/news/0414/14ante.html">
PC Week (April 14, 1997):  IBM, Netscape Up Web Ante</a>)
<p>
Another example, and one that confused many users, is shown by
the following program:
<pre>
   class Test {
      public static void main(String[] args){
         try {
         }
         catch (Exception e) {
            System.out.println("caught"); 
         }
      }
   }
</pre>
Jikes accepts this program but issues the warning:
<pre>
          catch (Exception e) {
                 <--------->
  *** Caution: This catch block is unreachable: there is 
      no exception whose type is assignable to 
      "java/lang/Exception" that can be thrown during
      execution of the body of the try block

</pre>
<p>This was the most frequently reported problem when Jikes first appeared.
 It took several months
to confirm that Jikes was right all along. See 
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery2">
Query #2 to Sun
</a> for the full story.

<h4>Cyclic scoping.</h4>
<p>Jikes rejects the program:
<pre>
  class X extends Y.Z {}
  class Y extends X.Z {}
</pre>
because Jikes checks for cycles by grouping types as follows:
<ul>
<li>Types that are package members form a group.</li>
<li>Within the body of a given type, all the inner types immediately
    declared in it form a group. In other words, if we look at the
    complete name of a type beginning with the name of its outermost
    enclosing type, all types that share the same prefix form a group</li>
</ul>
When a type T "extends" or "implements" a type U, we find the
innermost enclosing group that contains an enclosing type Tx of
T (which may be T itself) and an enclosing type Ux of U
(which may be U itself) and add a dependence edge from Tx to Ux.
We then check for cycles in the graph induced by this relationship.
<p>
Consider the following example:

<pre>
class Z {}

class W extends Z
{
    class A
    {
        class x extends B {}
        class y extends x {}
    }

    class B
    {
        class x extends A.x {}
    }

    class C extends B.x {}
}
</pre>

Its dependence graph contains the following edges:
<p>
<ul>
<li> <code>W->Z</code>, since <code>W</code> and <code>Z</code> are both package members</li>
<li> <code>W.A->W.B</code>, because type 
<code>W.A.x</code> extends <code>W.B</code></li> 
<li> <code>W.A.y->W.A.x</code>, because type 
<code>W.A.y</code> extends <code>W.A.x</code></li> 
<li> <code>W.B->W.A</code>, because type 
<code>W.B.x</code> extends <code>W.A.x</code></li> 
<li> <code>W.C->W.B</code>, because type 
<code>W.C</code> extends <code>W.B.x</code></li> 
</ul>

<p>
This graph has a cycle: <code>W.A->W.B->W.A</code>. So Jikes rejects
this program:
<pre>
Found 3 semantic errors compiling "Z.java":

     5.     class A
                      ^
*** Semantic Error: The class "W$A" is circularly defined with
    its super type(s)
  
    ...
</pre>

<p>Another example of cyclic dependence is found in the following code scheme used in some forms
of the Swing package:
<pre>
    class C implements C.I {
        ...
        interface I { ... }
    }
</pre>

<p> This example is cyclic by Jikes's model of dependence. We asked Sun 
about this usage: 
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery31">
Query #31 to Sun: Rules of inheritance of class members</a>.
Their response agrees with our interpretation that this usage is erroneous.

<h4>Queries to Sun</h4>
<p>Here are some more examples of issues related to interpreting the language specification:
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery1">
Query #1 to Sun: Inner Static 
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery2">
Query #2 to Sun: Unreachable Statements
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery3">
Query #3 to Sun: Dependence 
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery4">
Query #4 to Sun: Are block-level inner interface declarations allowed?
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery5">
Query #5 to Sun: String Concatenation Operator + and void 
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery6">
Query #6 to Sun: Getting a line on the LineNumberTable
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery7">
Query #7 to Sun: Setting of InnerClasses_attribute inner_class_access_flags
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery8">
Query #8 to Sun: Scope of Local Variable Declarations and Local Classes
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery9">
Query #9 to Sun: Qualifying new for static inner class 
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery10">
Query #10 to Sun: Can a class access its own private methods via a subclass? 
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery11">
Query #11 to Sun: Access to members in anonymous classes
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery12">
Query #12 to Sun: Anonymous inner classes should be final for instanceof and casts
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery13">
Query #13 to Sun: Access to inner classes
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery14">
Query #14 to Sun: Unreachability and do-while
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery15">
Query #15 to Sun: Access control bug with protected member of sibling/outer classes
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery16">
Query #16 to Sun: Floating point and bitwise operators
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery17">
Query #17 to Sun: Compile-time evaluation of constant expressions
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery18">
Query #18 to Sun: Explicit versus implicit setting of attributes, servialVersionUID algorithm
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery19">
Query #19 to Sun: Octal escapes in string literals
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery20">
Query #20 to Sun: What does "package-private method" mean?
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery21">
Query #21 to Sun: Name resolution
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery22">
Query #22 to Sun: Circularity problem?
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery23">
Query #23 to Sun: Packages and non-existing directories
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery24">
Query #24 to Sun: Protected
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery25">
Query #25 to Sun: Can user-deifned package have a type named "java"?
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery26">
Query #26 to Sun: Acceptability of unreachable byte code
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery27">
Query #27 to Sun: Representation of null value
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery28">
Query #28 to Sun: Use of anonymous class in explicit constructor invocation
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery29">
Query #29 to Sun: When can the ConstantValue attribute be used?
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery30">
Query #30 to Sun: Labeled statements and nested classes
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery31">
Query #31 to Sun: Rules of inheritance of class members
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery32">
Query #32 to Sun: Verification problem
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery33">
Query #33 to Sun: Field resolution for interfaces
</a>

<h4>The Unofficial Java Spec Report</h4>
</b></a></h3>
<p><a href="http://www.dina.kvl.dk/~jsr">
The Unofficial Java Spec Report</a>

is an unofficial site that covers problems with the Java Language
Specification, the Java Virtual Machine Specification, and the core API
documents. It is maintained by Roly Perera and Peter Bertelsen, and we 
wish to thank them for their service to the Java community.

<p>Starting with Jikes v0.28, we will attempt to track the recommendations
of the unofficial report, and implement them where feasible. The
current status for the 1.1 portion in Issue 9 (22 May 1998) is as follows:<p>
<ul>
<li>No definition of cyclic scoping -- Jikes has its defintion, as described earlier.    
<li>Resolution of ambiguous names.  Implemented.
<li>
    Access to protected members across nest siblings.  Implemented.
<li>
Can nested interfaces redundantly be declared static? -- Yes.
<li>
    Behavior of <code>new</code> when qualified with an expression that evalutes to
 <code>null</code> is undefined -- Implemented.
<li>
 Rule for making inacessible classes implicitly final is too lax -- 
    Jikes does not make this transformation.
<li>
Reachability of instance initializers and constructors undefined -- Implemented.
<li>
    Initialization requirements for blank final fields incorrect -- Implemented.
<li>
When qualified <code>new</code> or <code>super</code> can be used unspecified --
    Implemented.
<li>
Blank finals and interface fields -- Implemented.
<li>When may <code>this</code> be used in an explicit constructor invocation -- Implemented.
<li>
New hiding rules for parameters and local variables -- implemented.
<li>Blank finals and <code>try</code> statements -- implemented.
<li>
Blank finals and loops -- implemented.
<li>
Unclear whether forward referencing rule changes -- implemented.
<li>Transformations for anonymous classes unspecified -- implemented.
<li>Private methods implicitly final -- implemented.
</ul>
<h3><a name="results"><b>What can I do if I don't get the same
results when using class files generated by Jikes?</b></a></h3>

<p>It is possible that your current compiler was miscompiling the
program and Jikes got it right.  Jikes may have miscompiled your
program and we would appreciate your reporting the problem.  Here are
some steps that may clarify the situation. 

<p>When you run your program using the Java virtual machine, run
<code>java</code> with the option <code>-verify</code> to enable
bytecode verification. If verification this shows one or more class
files are faulty, you've found a bug in Jikes.  Please tell us about
it. 

<p>You should also to see if the Java virtual machine is using a JIT,
in which case you should try with the JIT disabled. We have seen
cases when JIT's fail with class files produced by Jikes, even though
these class files pass verification.  <p>Otherwise build two sets of
class files, one using your current compiler and one using Jikes.
Then, selectively substitute those produced by Jikes until you find a
class file generated by Jikes whose use results in other than the
expected output. If it appears that Jikes is at fault, please tell us
about it. 

<h3><a name="bugs"><b>How do I report bugs?</b></a></h3>

<p>
You can report bugs via the web to the Jikes Project at
<a href="http://ibm.com/developerworks/opensource">http://ibm.com/developerworks/opensource</a>.

<p>

It helps if you include a small program showing the problem -- doing
so raises the probability of a quick resolution.

<h3><a name="whyis"><b>Why did IBM make the source available?</b></a></h3>

<p>Work on what is now known as Jikes began in January 1996 when one
of us (Philippe) decided to study the problem of compiling Java. The
other (Dave) joined the project in April 1996, and started out by
writing the bytecode generator. We have worked full-time on the
compiler ever since.

<p>We released Jikes in binary form in April 1997. During the spring
of 1998 we received many requests for a Linux version.  Jikes for
Linux was released on 15 July 1998 -- the response was overwhelming.
Jikes had more downloads in the three months after the announcement
than in the fifteen months before the announcement.  The increase in
downloads was not just for the Linux version: there was a
corresponding surge for the Win95/NT version. We also got many bug
reports -- our main goal in putting out this version.

<p>We knew that putting out a version for Linux would inevitably
raise the question, "Where's the source?"  We received many notes and
comments from users suggesting why this would be a good idea, and
prepared a <a href=
"http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/JikesOpenSourceUserCommentsSummary">
Summary of User Comments</a>.  We found their comments persuasive,
and began several months of work that resulted in the release of the
source for Jikes in December 1998. This marked the start of one of
IBM's first efforts in the open-source arena.
<p>
The source was released in part to make a very visible demonstration
of IBM's commitment to open standards and to Java, to make Jikes more
reliable and accessible, to encourage more widespread use of Java, to
encourage standardization of Java, and to gain some experience
actually running an open-source project.


<h3><a name="whatcanido"><b>What can I do with the source?</b></a></h3>

<p>Don't forget to read the license carefully. It explains in detail what you can and cannot do.

<p>You can pretty much do whatever you want -- as long as we get some
acknowledgment.  You can distribute it in binary or source form, take
all or part of it and put it in something else, and then redistribute
it.  It's all up to you.

<p>However, IBM retains control of the names "IBM" and "Jikes<sup><small>TM</small></sup>". You
can't use them without our permission.

<p>You are under no obligation to tell us what you are doing with the
source, or to inform us of any changes you make.

<h3><a name="build"><b>How do I compile the source?</b></a></h3>

<p>To build on a Unix system, try
<pre>
    cd jikes/src 
    ./configure
    make
</pre>
<p>If this doesn't work, and you have access to <code>autoconf</code>, you can make
the appropriate edits to the file <code>configure.in</code> and rebuild <code>configure</code>.
<p>Otherwise, you can try the file <code>Makefile.hand</code>; it
should work with most
<code>make</code> programs that are available.  It's written to not
assume any particular version of <code>make</code>, and currently consists of a
series of clauses for each of the ports we have done to date, with,
of course, the last clause encountered being the one used to effect
compilation.  Note that some versions assume particular directory
structures, and you will have to make appropriate changes.

<p>To build the source from scratch, do:
<pre>
    cd jikes/src
    make -f Makefile.hand clean
    make -f Makefile.hand
</pre>

<p>Some of the source files are machine-generated. To see what's
going on here do:

<pre>
    touch java.g
    make
</pre>

<p>If you haven't yet done so, you can  download the Jikes
Parser Generator</a> in its source form from the Jikes Project at
<a href="http://ibm.com/developerworks/opensource">
http://ibm.com/developerworks/opensource</a>
, compile it, install it as
<code>jikespg</code> somewhere on your <code>PATH</code> and run
<code>make</code> again.

<p>We rarely need to run the parser generator.  The published Java
grammar is well-crafted; indeed, we don't recall having to make any
changes to make it acceptable as input to the parser generator. The
rare changes to <code>java.g</code> are those needed to effect a
change in the action code. 

<p>Whenever you start work on a new variant, it is useful to modify
the version info. This is contained near the end of the file
<code>jikes.cpp</code>. This is the text that is printed out when
<code>jikes</code> is invoked with no arguments.

<h3><a name="test"><b>How do I test the compiler?</b></a></h3>

<p>We currently test new versions of the compiler using these tests
<ul>
<li>The <code>derek</code> tests, written by Derek Lieber of IBM for testing a java virtual
machine he wrote early in 1996,</li>
<li>The <code>hpj</code> tests, written by members of the High Performance Compiler for
Java team.</li>,
<li>The <code>spec</code> tests based on the program fragments in the
published Java Language Specification,</li>
<li>Version 2.1.1. of the Modena Test Suite,</li>
<li>The <code>lang</code> component of Sun's JCK test suite for JDK 1.2.</li>
</ul>

<p>The Jikes Compiler source distribution includes the
<code>derek</code> and <code>hpj</code> tests to provide a
rudimentary regression test facility. The test set also include the
<code>pr</code> tests. These are based on the Problem Reports from
094 on that we have received this year.  The problem reports can be
found in the <a
href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf">
Jikes Discussion Database</a>.  The <code>pr</code> test suite is a
work in progress and we welcome volunteers who want to work with us
to bring the test set to a usable state.

<p>The tests are available as a collection of files
<code>jikestst</code>. The file <code>jikestst.htm</code> in the main
directory for the tests contains instructions on their installation
and use.

<p>The tests are intended mainly for regression testing and are by
no means meant to be interpreted as a comprehensive test of
compliance or conformance.
</body>
</html>
